class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        
        Set<List<Integer>> res = new HashSet<>();
        List<Integer> set = new ArrayList<>();
        powerSet(0,set,nums,res);
        List<List<Integer>> result  = new ArrayList<>(res);
        return result;
        
    }
    static void powerSet(int index, List<Integer> set, int[] nums,  Set<List<Integer>> res ){
        //base condition when index crosses n 
        if(index == nums.length){
            res.add(new ArrayList<>(set));
            return;
        }
        //take it 
       // System.out.println(" index " + index);
        set.add(nums[index]);
        powerSet(index+1, set, nums, res);
        
        //not take it
        set.remove(set.size()-1);
        powerSet(index+1, set, nums, res);

        
    }
}

above solution is not fully correct

//better and optimized solution 



class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);//to remove the duplicates while traversing 
        List<List<Integer>> res  = new ArrayList<>();
        powerSet(res,new ArrayList<>(),nums,0);
        return res;
        
    }
    static void powerSet(List<List<Integer>> result, List<Integer> ds, int[] nums, int index){
        //add the deep copy into the result 
        result.add(new ArrayList<>(ds));
        for(int i = index ; i<nums.length; i++){
            if(i > index && nums[i]==nums[i-1]) continue;
            ds.add(nums[i]);
            powerSet(result,ds,nums,i+1);
            ds.remove(ds.size()-1);
            
        }

        
    }
}
