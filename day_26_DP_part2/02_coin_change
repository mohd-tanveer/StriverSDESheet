class Solution {
    public int coinChange(int[] coins, int amount) {
        
        int dp[][] = new int[coins.length][amount+1];
        for(int[] row:dp){
            Arrays.fill(row,-1);
        }
        int ans = solve(coins,amount,coins.length-1,dp);
        
        
        return ans >=(int)Math.pow(10,9)?-1:ans;
    }
    static int solve(int[] coins, int amount,int i,int[][] dp){
        
        if(i == 0){
           
            //if index == 0 either we can form the target with given denomination or can't
            if(amount%coins[0] == 0) return amount/coins[0];
            else
                return (int)Math.pow(10,9);
        }
       //take it 
        if(dp[i][amount] != -1) return dp[i][amount];
        
        int take=Integer.MAX_VALUE;
        if(amount-coins[i] >= 0){
            take = Math.min(take,1+solve(coins,amount-coins[i],i,dp));
                    //stying at same index will be considerd in not take scenario of next step
        }
        //not take it 
       
        int notTake = 0+solve(coins,amount,i-1,dp);
        
        return dp[i][amount] = Math.min(take,notTake);
                       
    }
}
